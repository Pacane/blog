# JSON serialization in Dart with Dogma 

Serialization and deserialization of objects to/from JSON Dart is a hot topic, since there's no native way of doing that easily.

I'm gonna quote Dart's landing page here:

> [Dart is made for] for building web, server, and mobile apps.

Why would it be hard to do such an easy job for a language supposed to be "web oriented"?. The answer lies in `dart2js`, the Dart to Javascript compiler.

The way one can convert an object in JSON in Dart is with a `Map` that gets translated in JSON.

Let's see the idiomatic way of writing a class that'll be translated from/to JSON.

```dart
import 'dart:convert';

class Person {
  String name;
  num age;

  Person();

  Person.fromJson(Map json) {
    name = json['name'];
    age = json['age'];
  }

  Map toJson() => {
    'name': name,
    'age': age
  };
}

main() {
  var p = new Person()
    ..name = 'john'
    ..age = 20;

  String jsonEncoded = JSON.encode(p);
  print(jsonEncoded);

  var decoded = new Person.fromJson(JSON.decode(jsonEncoded));
}

```

The above code shows how Dart manages to serialize/deserialize an object into JSON. The 'JSON.encode' function calls the `toJson` method on an object by default.

Imagine if you had nested objects, you would have to manage the hierarchy of `Map`s on your own. And your certainly don't want to do this job yourself for big projects.

Writing a `toJson` method and a `fromJson` constructor for tens and hundreds of model classes is not what I call something productive.

The community has come with different solutions to get over this problem.

## Reflection
The first one would be to use Reflection. I'm not going to talk a lot about it since it's not really good. The concept is to use introspection of code at runtime to scan the code base (the fields and their types) to write these conversion methods at runtime.

The problem with this is that to produce a small and efficient generated code, `dart2js` optimizes, tree-shakes and minifies the code. When using reflection, `dart2js` cannot minify the names of the fields/functions used by reflection, and therefore, when you use reflection, the code size of your web application will most likely explode.

## Transformer
The second one, can be good, but it's not perfect. Some libraries out there write some code to parse some annotations used on classes and fields, so that objects can then be serialized or deserialized. I know that [redstone_mapper](https://pub.dartlang.org/packages/redstone_mapper) does that.

The problem with code generation during the transformers phase, is that the generated code can hardly be debugged. Indeed, the code that's changed or generated by a tranformer is usually not available to put breakpoints and inspect.

## Code generation
The last solution is to my eyes, the best. Code generation is pretty much like transformers, except that the code that is generated is available when developing. So you can easily find out bugs in generated code, because you have access to the analyzer, but you can also put breakpoints when debugging at runtime.

This is what [dogma-convert](https://github.com/dogma-dart/dogma-convert) does. 

## Dogma
Dogma is a set of packages made by [Don Olmstead](https://github.com/donny-dont), which contains a few packages that can help you with all the JSON serialization problems. You can generate model classes from different type of schemas, but the part I want to show here will be the generation of encoding and decoding classes for JSON conversion.

First, if you want a class' fields to be mapped 1 to 1, as is, to JSON, you don't need to annotate any field. Otherwise, if you want for example, to use different names for the class in Dart and the object in JSON, you can annotate the field with `@Serialize.field('id')`.

Here's a sample class I have in one of my projects:

```dart
import 'package:dogma_convert/serialize.dart';

class Attachment {
  @Serialize.field('id')
  int id;
  @Serialize.field('from_url')
  String fromUrl;
  @Serialize.field('image_url')
  String imageUrl;
}
``` 

Once you have the following class, you have to export it in a `models.dart` library. `dogma-convert` provides an executable that you can use from a script to generate the converters. See [this](https://github.com/Pacane/SlackHistoryKeeper/blob/master/shared/build.dart) for a sample build script.

The generated encoding/decoding classes look like this:
```dart
library slack_history_keeper_shared.src.convert.attachment_convert;


//---------------------------------------------------------------------
// Standard libraries
//---------------------------------------------------------------------


import 'dart:convert';

//---------------------------------------------------------------------
// Imports
//---------------------------------------------------------------------


import 'package:dogma_convert/convert.dart';
import 'package:slack_history_keeper_shared/models.dart';

//---------------------------------------------------------------------
// Library contents
//---------------------------------------------------------------------


/// A [ModelDecoder] for [Attachment].
class AttachmentDecoder extends Converter<Map, Attachment>
    implements ModelDecoder<Attachment> {
  @override
  Attachment create() => new Attachment();
  @override
  Attachment convert(Map input, [Attachment model]) {
    model ??= create();

    model.id = input['id'];
    model.fromUrl = input['from_url'];
    model.imageUrl = input['image_url'];
    return model;
  }
}

/// A [ModelEncoder] for [Attachment].
class AttachmentEncoder extends Converter<Attachment, Map>
    implements ModelEncoder<Attachment> {
  @override
  Map convert(Attachment input) {
    var model = {};

    model['id'] = input.id;
    model['from_url'] = input.fromUrl;
    model['image_url'] = input.imageUrl;

    return model;
  }
}

```

You can now add a `toJson` method that delegates to new generated Encoder to your original model class to integrate seamlessly with existing libs that use JSON Codec (like Redstone for example).

On client side apps, you can use the Decoders like this:

```dart
final EmoticonDecoder emoticonDecoder = new EmoticonDecoder();

Future<Map<String, Emoticon>> fetchEmoticons() async {
  var result = await client.get('$apiUrl/emoticons');

  var json = JSON.decode(result.body) as List<Map>;

  var association = <String, Emoticon>{};

  json
	  .map((Map m) => emoticonDecoder.convert(m))
	  .forEach((Emoticon e) => association[e.name] = e);

  return association;
}
```

## Conclusion
So if you want keep a nice small code size for your web app, or even to have a clean separation of concern, with low maintenance for JSON serialization, I'd recommend to use Dogma.

If has been pretty easy for me to generate the mapping code between Dart and JSON, and use the converters in my code base.

That's all folks!
